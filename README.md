# ðŸš€ build-your-own-react

> A **re-engineering version of**  **[Preact](https://github.com/preactjs/preact), [Redux](https://github.com/reduxjs/redux), and [React Redux](https://github.com/reduxjs/redux)** with worflows and explanations.

### Description

Most of you have already read many blogs explaining how React/Redux/React Redux works with some source code snippets.  It seems that you can handle those interview questions successfully. Yet, you are still far from being a React Jedi until you can build, assemble, and customize them by yourself. 

This repo contains 3 parts: my-react, my-redux and my-react-redux. It is actually a **re-engineering version of**  **[Preact](https://github.com/preactjs/preact), [Redux](https://github.com/reduxjs/redux), and [React Redux](https://github.com/reduxjs/redux).**

I will walk you through 3 basic demos with some XMind workflows to help both of us better understand what's going on under the hood. 



###Play By yourself

```bash
git clone https://github.com/magentaqin/build-your-own-react.git

yarn install

yarn start
```



### ðŸ™Œ Demos

#### Demo One: Hello World

You must be familiar with how to render "Hello World" in react. However, you might not know what happened behind the scene. What will babel-parser do to the parsed jsx syntax?  When will invoke DOM API to create dom node? Will my-react invoke diff function in the initail rendering process? How many times will it invoke diff function?

```jsx
import myReact, { x } from 'my-react';

class App extends myReact.Component {
  componentWillMount() {
    console.log('I WILL MOUNT.');
  }

  componentDidMount() {
    console.log('I AM MOUNTED.')
  }

  render() {
    return (
      <h1>Hello World</h1>
    );
  }
}

myReact.render(<App />, document.getElementById('root'));
```

This workflow below explains how a simply "Hello World" is rendered through `my-react`.

Basically, there are two steps.  Step one is to call `createElement` function and Step two is to call `render` function. 

You can define babel-parser pragma option as `h`(Preact defines it as `h`) or anything you like. Here I define pragma as `x` in webpack.config.js and export  ` createElement` function as `x` in react/src/index.js.  Babel parser will call `x` (alias `createElement`), and pass the transformed jsx syntax to `createElement` function.

Have a look at `type` passed to `createElement`:

```javascript
 Æ’ App() {
   return _myReact$Component.apply(this, arguments) || this;
 } 
```

and the returned vnode that will be passed to `render` function is:

```javascript
vnode {
  constructor: undefined,
  key: null,
  props: {},
  ref: null,
  type: Æ’ App()
  _children: null,
  _component: null,
  _depth: 0,
  _dom: null,
  _lastDomChild: null,
  _parent: null,
}
```

**To understand what's going on during `render` process, you have to figure out  what those 4 recursively called diff() functions respectively do.**

Before diff() is called, vnode is set to be `parentDom._children`, and new vnode has been generated by calling `createElement` 2nd time.

**diff() called 1st time**:  create instance of `Component`.

**diff() called 2nd time**: 

1) invoke `componentWillMount` lifecycle and push `componentDidMount` to c._renderCallbacks queue.

2) c.render(c.props, c.state.c.context)

```javascript
// "render" under the hood
Æ’ render() {
  return Object(my_react__WEBPACK_IMPORTED_MODULE_0__["x"])("h1", null, "Hello World");
}
```

**diff() called 3rd time**: document.createElement("h1")

**diff() called 4th time**: 

1) document.createTextNode("Hello World")

2) parentDom.appendChild(newDom)

See how the property values of  `vnode` change during the `rendering` process.

| vnode's property | createElement called 2nd time        | 4th diff popped | 3rd diff popped | 2nd diff popped | 1st diff popped |
| ---------------- | ------------------------------------ | --------------- | --------------- | --------------- | --------------- |
| props            | { children: [previousVnode]}         | "Hello World"   |                 |                 |                 |
| type             | (props) => { return props.children } | null            |                 |                 |                 |
| _children        | null                                 | null            |                 |                 |                 |
| _component       | null                                 | null            |                 |                 |                 |
| _depth           | 0                                    | 3               |                 |                 |                 |
| _dom             | null                                 | null            |                 |                 |                 |
| _lastDomChild    | null                                 | null            |                 |                 |                 |
| _parent          | null                                 |                 |                 |                 |                 |

####Demo Two: Render List

#### Demo Three: Counter



### Troubleshooting

**1. What does "re-engineer" mean? Does it mean "copy and paste code"?**

If you define "copy and paste code" as `git clone` to this project, the answer is "no".   

I changed babel option pragma from 'h' to 'x'.

**2.The differences between `Preact` and `React`? Why do you choose `preact` instead of `react` to re-engineer?**

* The way to compile JSX.
https://babeljs.io/docs/en/babel-preset-typescript
option `jsxPragma` is set to `h` in Preact, while it is set to `React` in React. It means: Babel will transform `<div id="hello"/>` to `React.createElement("div", {id: "hello"})` by default and "jsxPragma: h" will generate it to `h("div", { id: "hello"})`. To know more about `h`, you can read this https://jasonformat.com/wtf-is-jsx/ and play this demo  https://codepen.io/developit/pen/aOYywe.

* Browser Compatible.

  

Some comment flags I wrote while re-engineering:

* TODO:
  I haven't figure out why it is necessary to put code there.

* UPDATE SOURCE CODE:

* SECURITY WORK.

* BROWSER COMPATIBLE WORK.

